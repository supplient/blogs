<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>测试用博客</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="https://gist.githubusercontent.com/supplient/1726b3acbfed278f54b66cf11129a43b/raw/62b874d98f72005d18b9b2a05d3be6815959b51b/gh-pandoc.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">测试用博客</h1>
</header>
<h1
id="论文阅读fast-simulation-of-mass-spring-systems最优化视点">论文阅读：Fast
Simulation of Mass-Spring Systems（最优化视点）</h1>
<p>本文为对<a
href="https://www.cs.utah.edu/~ladislav/liu13fast/liu13fast.html">Fast
Simulation of Mass-Spring Systems</a>的阅读笔记。</p>
<p>本文站的视点和原文已经截然不同了，完全可以把本文当作独立的文章进行阅读。
本文里所介绍的方法是我按个人理解提炼出来的，但内核应该是一样的。</p>
<p>本文跟我的<a
href="https://zhuanlan.zhihu.com/p/511502862">另一篇阅读笔记</a>站的视点稍有不同，所以另外写了这一篇。
我个人觉得本文的观点更利于理解。</p>
<p>本文里大段篇幅都和<a
href="https://zhuanlan.zhihu.com/p/518244355">XPBD的这篇最优化视点</a>一模一样，这是有意为之的，我想让两篇文章都独立成文，但又容易进行比较。</p>
<p>一些记号约定： * 位移为<span
class="math inline">\(x\)</span>，速度为<span
class="math inline">\(v\)</span>，加速度为<span
class="math inline">\(a\)</span>，时间为<span
class="math inline">\(t\)</span>。 * 共<span
class="math inline">\(n\)</span>个质点。 *
所有向量均为列向量。标量对<span
class="math inline">\(n\)</span>维向量求导，结果为<span
class="math inline">\(n\)</span>维向量；<span
class="math inline">\(m\)</span>维向量对<span
class="math inline">\(n\)</span>维向量求导，结果为<span
class="math inline">\(m\)</span>行<span
class="math inline">\(n\)</span>列矩阵。 * 上标表示时刻，例如<span
class="math inline">\(x^n\)</span>表示第<span
class="math inline">\(n\)</span>个时刻的位移。 *
下标表示某个质点的值，例如<span
class="math inline">\(x_i\)</span>表示第<span
class="math inline">\(i\)</span>个质点的位移。 * 已知<span
class="math inline">\(n\)</span>时刻的所有状态信息，包括但不限于<span
class="math inline">\(x, v,
a\)</span>。（注意这里为了和其他地方的标记统一，所以<span
class="math inline">\(n\)</span>同时具有<span
class="math inline">\(n\)</span>维和第<span
class="math inline">\(n\)</span>个时刻的含义，有点混用了） *
质量矩阵为对角矩阵<span class="math inline">\(M=diag\{m_1, m_2, \cdots,
m_n\}\)</span>，其中<span class="math inline">\(m_i\)</span>为第<span
class="math inline">\(i\)</span>个质点的质量。设质量与时间无关，始终不变。
* <span class="math inline">\(\Delta
t\)</span>为时步长度，即每帧之间的时间长度<span
class="math inline">\(Δt=t^{n+1}-t^n\)</span>。 * <span
class="math inline">\(∇U\)</span>为函数<span
class="math inline">\(U\)</span>对<span
class="math inline">\(x\)</span>求一阶导，<span
class="math inline">\(H(U)\)</span>为<span
class="math inline">\(U\)</span>对<span
class="math inline">\(x\)</span>求二阶导（即海森矩阵）。</p>
<h1 id="方法">1. 方法</h1>
<p>我们的目标是要求出当前位移<span
class="math inline">\(x\)</span>，根据速度定义，其满足：</p>
<p><span class="math display">\[
\tag{1.1}
x^{n+1} = x^n + \int_{t^n}^{t^{n+1}}vdt
\]</span></p>
<p>速度又根据加速度定义，满足：</p>
<p><span class="math display">\[
\tag{1.2}
v = v^n + \int_{t^n}^{t}adt
\]</span></p>
<p>根据牛顿第二定律，可知：</p>
<p><span class="math display">\[
\tag{1.3}
a=M^{-1}F
\]</span></p>
<p>把式1.3代入到式1.2里，就能求出<span
class="math inline">\(v\)</span>关于<span
class="math inline">\(t\)</span>的函数，然后再代进式1.1里就能求出<span
class="math inline">\(x^{n+1}\)</span>关于<span
class="math inline">\(t^{n+1}\)</span>的函数。 不过因为<span
class="math inline">\(F\)</span>通常都很复杂，所以直接求积分不太现实，使用数值积分的方法近似求解比较现实。</p>
<p>对式1.1, 1.2<strong>应用隐式欧拉法（第一个处理）</strong>：</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
    x^{n+1} = x^n + Δtv^{n+1} \\
    v^{n+1} = v^n + Δta^{n+1} \\
\end{aligned}
\right.
\]</span></p>
<p>这一近似就让<span
class="math inline">\(x^{n+1}\)</span>变得更容易求解了。为了让解更加明显，我们对它稍作变形，把下式的<span
class="math inline">\(v^{n+1}\)</span>代进上式，从而消掉并不是目标项的<span
class="math inline">\(v^{n+1}\)</span>，得到：</p>
<p><span class="math display">\[
x^{n+1}=x^n+Δtv^n+Δt^2a^{n+1}
\]</span></p>
<p>求解这一关于<span class="math inline">\(x^{n+1}\)</span>的方程即可。
不过<span class="math inline">\(a^{n+1}\)</span>还没有展开。
如果展开的话，因为<span
class="math inline">\(a^{n+1}=M^{-1}F^{n+1}\)</span>， 而<span
class="math inline">\(F^{n+1}\)</span>通常都是关于<span
class="math inline">\(x^{n+1}\)</span>或<span
class="math inline">\(v^{n+1}\)</span>的非线性函数，
这就导致上式变成了一个关于<span
class="math inline">\(x^{n+1}\)</span>的非线性方程。
我们希望能求解得更容易点。</p>
<p>我们先把这个非线性方程给写出来，为了方便，记<span
class="math inline">\(Δx=x^{n+1}-x^n-Δtv^n\)</span>。则有方程：</p>
<p><span class="math display">\[
\tag{1.4}
MΔx-Δt^2F(Δx)=0
\]</span></p>
<p>我们的目标是求解式1.4，这在解附近等价于求解以下最优化问题：</p>
<p><span class="math display">\[
\min_{Δx}\ G(Δx)=\frac{1}{2}Δx^TMΔx-Δt^2∫F(Δx)d(Δx)
\]</span></p>
<p>这是因为在没有约束条件的情况下，<span
class="math inline">\(G(Δx)\)</span>的极值点必定满足<span
class="math inline">\(\frac{∂G}{∂Δx}=MΔx-Δt^2F(Δx)=0\)</span>，也就是1.4式成立。</p>
<p>为了能方便地处理<span
class="math inline">\(F\)</span>，此处再引入一个假设：<strong><span
class="math inline">\(F\)</span>为保守力（第二个处理）</strong>，即有势能场<span
class="math inline">\(U\)</span>满足：</p>
<p><span class="math display">\[
∇U=-F
\]</span></p>
<p>则最优化问题可记为：</p>
<p><span class="math display">\[
\tag{1.5}
\min_{Δx}\ G(Δx)=\frac{1}{2}Δx^TMΔx-Δt^2U(Δx)
\]</span></p>
<p><span class="math inline">\(G\)</span>的前半项<span
class="math inline">\(\frac{1}{2}Δx^TMΔx\)</span>是个关于<span
class="math inline">\(Δx\)</span>的二次项，求它的极值点很容易。
所以<span class="math inline">\(G\)</span>的复杂度由其后半项<span
class="math inline">\(U\)</span>来决定。 通常而言，<span
class="math inline">\(U\)</span>都挺复杂的，不是一个简单的二次函数。</p>
<hr />
<p>（下文和<a
href="https://zhuanlan.zhihu.com/p/518244355">XPBD的那篇</a>产生分歧）</p>
<p>为了引出后文，我们先尝试一种不可行的方法。</p>
<p>怎样的函数比较好求极值呢？二次函数最好求，因为它的梯度是个线性项，所以求解极值点条件（目标函数的梯度为0）时就是解个线性方程组，而解线性方程组一般认为都是比较容易的。</p>
<p>所以我们希望<span class="math inline">\(U\)</span>是个二次函数。</p>
<p>一个简单的想法是将<span
class="math inline">\(U\)</span>泰勒展开：</p>
<p><span class="math display">\[
\tag{1.6}
U(x^{n+1})≈U(x^n)+∇U(x^n)^TΔx+\frac{1}{2}Δx^TH(U)(x^n)Δx
\]</span></p>
<p>右边这个近似函数显然是个关于<span
class="math inline">\(Δx\)</span>的二次函数。</p>
<p>这可能也确实是一种做法，可能也有人这么做过（有待调研）。</p>
<p>这一做法存在的问题是它需要把<span
class="math inline">\(H(U)\)</span>给写出来，可是不是所有<span
class="math inline">\(U\)</span>都那么容易把<span
class="math inline">\(H(U)\)</span>给写出来的。</p>
<p>下面我们以弹簧约束为例讨论该问题（后文中全部都是在讨论弹簧约束）。</p>
<p>设有一组弹簧约束<span class="math inline">\(C=[C_1\ C_2\ \cdots\
C_m]^T\)</span>, <span
class="math inline">\(C_i=||x_{s_i}-x_{t_i}||-l_i\)</span>, 其中<span
class="math inline">\(s_i, t_i, l_i\)</span>为已知量。</p>
<p>则弹簧势能<span
class="math inline">\(U=\frac{1}{2}C^TC\)</span>，它的梯度为：</p>
<p><span class="math display">\[
∇U=∇C^TC = \begin{bmatrix}
    \sum_i\frac{∂C_i}{∂x_j}C_i
\end{bmatrix}_{n×1}
\]</span></p>
<p>这里为了简略，只写了第<span
class="math inline">\(j\)</span>项的表达式，<span
class="math inline">\(∇U\)</span>为一个n维的列向量。
显然，它的二阶导<span
class="math inline">\(H(U)\)</span>已经相当难写出来了。
所以直接对弹性势能进行泰勒展开将其转换为二次函数是件困难的事情。</p>
<p>为了下文讨论的清晰直观，我们再引入一个新的常数矩阵<span
class="math inline">\(L\)</span>:</p>
<p><span class="math display">\[
A_{ij} =
\left\{
\begin{aligned}
    1&amp;, if\ j=s_i \\
    -1&amp;, if\ j=t_i \\
    0&amp;, otherwise
\end{aligned}
\right.
\]</span></p>
<p>其满足：</p>
<p><span class="math display">\[
Ax=
\begin{bmatrix}
    x_{s_1}-x_{t_1} \\
    x_{s_2}-x_{t_2} \\
    ⋯ \\
    x_{s_m}-x_{t_m} \\
\end{bmatrix}
\]</span></p>
<p>为了能找到一个<span
class="math inline">\(U\)</span>的二次函数近似，我们先把<span
class="math inline">\(U\)</span>给用另一种记法给展开：</p>
<p><span class="math display">\[
\begin{aligned}
    U
    &amp;= \frac{1}{2}C^TC \\
    &amp;= \frac{1}{2}\sum C_i^2 \\
    &amp;=
\frac{1}{2}\sum[(x_{s_i}-x_{t_i})^T(x_{s_i}-x_{t_i})-2l_i||x_{s_i}-x_{t_i}||+l_i^2]
\\
    &amp;= \frac{1}{2}x^TA^TAx - \frac{1}{2}\sum
l_i||x_{s_i}-x_{t_i}||+\sum l_i^2
\end{aligned}
\]</span></p>
<p>注意到<span
class="math inline">\(U\)</span>可以被分为三部分处理：二次项、复杂项、常数项。设：</p>
<p><span class="math display">\[
\begin{aligned}
    L &amp;= A^TA \\
    D(x) &amp;= -\frac{1}{2}\sum l_i||x_{s_i}-x_{t_i}|| \\
    C &amp;= \sum l_i^2
\end{aligned}
\]</span></p>
<p>则<span class="math inline">\(U\)</span>可以写成：</p>
<p><span class="math display">\[
\tag{1.7}
U = \frac{1}{2}x^TLx+D(x)+C
\]</span></p>
<p>注意到二次项和常数项的二阶导非常容易写出来：</p>
<p><span class="math display">\[
\begin{aligned}
H(\frac{1}{2}x^TLx) = L \\
H(C) = 0
\end{aligned}
\]</span></p>
<p>所以问题其实聚焦在这个<span
class="math inline">\(D(x)\)</span>的二阶导<span
class="math inline">\(H(D)\)</span>很难写出来。</p>
<p>因此我们就做了<strong>第三个处理：设<span
class="math inline">\(H(D)=0\)</span></strong>。此时有<span
class="math inline">\(U\)</span>的二阶导满足：</p>
<p><span class="math display">\[
\tag{1.8}
H(U) = L
\]</span></p>
<p>在这基础上再做<strong>第四个处理：把<span
class="math inline">\(U\)</span>给泰勒展开，近似为一个二次函数。</strong></p>
<p>把式1.8代入式1.6的泰勒展开里面，得到近似函数<span
class="math inline">\(U^*\)</span>：</p>
<p><span class="math display">\[
\tag{1.9}
U^*(Δx)=U(x^n)+∇U(x^n)^TΔx+\frac{1}{2}Δx^TLΔx
\]</span></p>
<p><span
class="math inline">\(U^*\)</span>里还算比较难写出来的就只有<span
class="math inline">\(∇U(x^n)\)</span>了，这个么，就用勤劳的双手解决吧！（上文中已经给出了<span
class="math inline">\(∇U\)</span>）</p>
<p>用新势能函数<span
class="math inline">\(U^*\)</span>取代式1.5的最优化问题里的<span
class="math inline">\(U\)</span>，得到新问题：</p>
<p><span class="math display">\[
\tag{1.10}
\min_{Δx}\ G(Δx)=\frac{1}{2}Δx^TMΔx-Δt^2U^*(Δx)
\]</span></p>
<p>其中<span class="math inline">\(U^*\)</span>是个关于<span
class="math inline">\(Δx\)</span>的二次函数。于是式1.10里的<span
class="math inline">\(G(Δx)\)</span>就是个关于<span
class="math inline">\(Δx\)</span>的二次函数，求它的极值点非常容易，我们对<span
class="math inline">\(Δx\)</span>求导，得到极值点条件方程：</p>
<p><span class="math display">\[
\tag{1.11}
\frac{∂G}{∂Δx} = MΔx - Δt^2[∇U(x^n)+LΔx] = 0
\]</span></p>
<p>上式中只有关于<span
class="math inline">\(Δx\)</span>的线性项，所以它也就只是个<span
class="math inline">\(\Delta
x\)</span>的线性方程组。至此，我们就得到了一套求解式1.1的方法。</p>
<h1 id="讨论">2. 讨论</h1>
<p>我们为了求解式1.1里的<span
class="math inline">\(x^{n+1}\)</span>，一共做了四个处理： 1.
应用隐式欧拉法计算数值积分 2.
假设作用力均为保守力，从而可以将原问题转换为最优化问题 3. 设<span
class="math inline">\(U\)</span>里的复杂项<span
class="math inline">\(D\)</span>的二阶导<span
class="math inline">\(H(D)=0\)</span> 4. 在第三个处理的基础上，用<span
class="math inline">\(U\)</span>的二阶泰勒展开近似<span
class="math inline">\(U\)</span></p>
<p>第一、三、四个处理是降低求解难度的核心步骤： *
第一个处理用近似方法计算数值积分。 * 第三、四个处理相当于是在对<span
class="math inline">\(U\)</span>做二阶泰勒展开时，只对<span
class="math inline">\(U\)</span>里的复杂项做了一阶泰勒展开，也就是只把那一部分给线性化了，对其他部分还是做二阶泰勒展开。
* 通常的做法是把整个<span
class="math inline">\(U\)</span>都给一阶泰勒展开的。</p>
<p>这一方法可能也能迁移到其他形式的势能上吧，只要能提取出来二次项就行了。</p>
</body>
</html>
