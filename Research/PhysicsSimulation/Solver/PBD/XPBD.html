<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>测试用博客</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="https://gist.githubusercontent.com/supplient/1726b3acbfed278f54b66cf11129a43b/raw/62b874d98f72005d18b9b2a05d3be6815959b51b/gh-pandoc.css" />
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">测试用博客</h1>
</header>
<p>#! https://zhuanlan.zhihu.com/p/510654097 # 论文阅读：XPBD</p>
<p>2022.5.11修订：添加了对引入<span
class="math inline">\(λ\)</span>的解释。</p>
<hr />
<p>本文为对<a
href="https://matthias-research.github.io/pages/publications/XPBD.pdf">XPBD:
Position-Based Simulation of Compliant Constrained
Dynamics</a>的阅读笔记。
本文并非翻译性质或公式推导的文章，内容与文中会有很大的出入，不过方法还是论文里的那套方法，只是会加入大量我的个人理解，同时还会删去我不感兴趣或不懂的部分。</p>
<p>需要的预备知识：对PBD多少有点了解，熟悉多元微分学，知道牛顿运动方程。</p>
<p>有不正之处欢迎指出。</p>
<h1 id="一一些约定">一、一些约定</h1>
<p>有<span class="math inline">\(n\)</span>个粒子，粒子位置为<span
class="math inline">\(x_i\)</span>（下文中将忽略<span
class="math inline">\(x_i\)</span>的维度，看着就像是在处理标量一样，但其实都可以直接迁移到向量上的），设<span
class="math inline">\(x=[x_1, x_2, \cdots, x_n]^T\)</span>。</p>
<p>每个粒子的质量为<span
class="math inline">\(m_i\)</span>，质量矩阵：</p>
<p><span class="math display">\[
M=\begin{bmatrix}
    M_1&amp;&amp;&amp;&amp; \\
    &amp;M_2&amp;&amp;&amp; \\
    &amp;&amp;M_3&amp;&amp; \\
    &amp;&amp;&amp;⋱&amp; \\
    &amp;&amp;&amp;&amp;M_n \\
\end{bmatrix},
M_i = \begin{bmatrix}
    m_i &amp; &amp; \\
    &amp; m_i &amp; \\
    &amp; &amp; m_i \\
\end{bmatrix}
\]</span></p>
<p>时步为<span class="math inline">\(\Delta t\)</span>。</p>
<h1 id="二总体">二、总体</h1>
<p>将物体视为只受两类力作用： * 势能力：只与粒子位置有关的势能力 *
例如弹性势能的弹力 * 外力：粒子之间相互独立无关的力 *
例如在任何位置都大小方向不变的重力、只与粒子速度有关的空气阻力 *
通常而言，如果某种力作用到一个粒子上会影响到其他粒子上同种力的大小或方向的话，那么我们就不会把它放进这里的外力</p>
<p>将每一时步分为两个小步： 1.
第一次求解运动方程：计算外力与惯性速度带来的位置变化 2.
第二次求解运动方程：计算势能力带来的位置变化</p>
<p>首先要思考的是“求解运动方程”意味着什么？</p>
<p>我们的最终目标是要求出每一帧起始的粒子位置<span
class="math inline">\(x\)</span>，求解该位置的方法就是求解常微分方程<span
class="math inline">\(\frac{\partial x}{\partial t} =
v\)</span>。但因为我们通常不可能直接求出解析解，特别是交互式应用里，而且一般也不需要解析解，所以我们一般会把它给离散化。</p>
<p>设第<span class="math inline">\(n\)</span>帧起始的粒子位置为<span
class="math inline">\(x^{n}\)</span>，则<span
class="math inline">\(x^{n+1} = x^n +
\int_{t_n}^{t_{n+1}}vdt\)</span>。各类数值方法（显式欧拉法、隐式欧拉、韦尔莱积分法等等）本质都是在想法子解出来后半那个积分。
在我们这边，求解<a
href="https://en.wikipedia.org/wiki/Equations_of_motion">运动方程</a>就是要求这个积分。</p>
<p>那么这里为什么分了两步呢？ 因为两步考虑的系统是不同的。
第一步只考虑到了外力与惯性速度，第二步只考虑到了势能力。通过区分开来这两部分，我们就能对其分别使用不同方法求解其运动方程。
这一方法当然有弊端：显然在进行第二步的时候我们会忽略第一步的存在，也就会导致第二步会抵消掉一部分第一步的结果。</p>
<h1
id="三第一次求解运动方程外力与惯性速度">三、第一次求解运动方程：外力与惯性速度</h1>
<p>XPBD选用的是<a
href="https://en.wikipedia.org/wiki/Verlet_integration">韦尔莱积分法</a>来进行这第一步：</p>
<p><span class="math display">\[
x^{n+1} = 2x^n - x^{n-1} + \Delta t^2M^{-1}F_{ext}
\]</span> 其中<span
class="math inline">\(F_{ext}\)</span>为外力和。（该式与原论文中的写法不太一样，只是因为我把<span
class="math inline">\(v^n\)</span>给代入进去了而已）</p>
<p>这一步与PBD没有任何区别。</p>
<p>他之所以选用韦尔莱积分法是因为在第二步求解势能力的位置变化时不会把速度显式更新，所以如果第一步用某种需要显式更新速度的积分法的话，那问题会变得麻烦很多。因此他就选用了韦尔莱积分法这一把速度隐式蕴含在位置里的方法。</p>
<p>[Note:
所以是不是改一改第二步以后，这个第一步也能用别的积分法呢？]</p>
<h1 id="四第二次求解运动方程势能力">四、第二次求解运动方程：势能力</h1>
<p>首先先用隐式欧拉法来求<span class="math inline">\(x^{n+1} = x^n +
\int_{t_n}^{t_{n+1}}vdt\)</span>：</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
    x^{n+1} &amp;= x^n + \Delta t v^{n+1} \\
    v^{n+1} &amp;= v^n + \Delta t a^{n+1}
\end{aligned}
\right.
\]</span></p>
<p>变换一下得到<span
class="math inline">\(a^{n+1}\)</span>的表达式：</p>
<p><span class="math display">\[
a^{n+1} = \frac{x^{n+1} - 2x^n + x^{n-1}}{\Delta t^2}
\]</span></p>
<p>为了方便，下文中将省略<span
class="math inline">\(n+1\)</span>的上标，并记<span
class="math inline">\(\tilde{x}≡2x^n-x^{n-1}\)</span>。</p>
<p>然后我们假设在这一步里考虑的总<a
href="https://en.wikipedia.org/wiki/Potential_energy#Work_and_potential_energy">势能</a>为<span
class="math inline">\(U(x)\)</span>，那么其对应的势能力为<span
class="math inline">\(F=-\nabla
U(x)\)</span>。因为这一步里只考虑这些势能力的作用效果，所以有<span
class="math inline">\(a=M^{-1}F\)</span>，代入得：</p>
<p><span class="math display">\[
\begin{equation}
-∇U(x) = M\frac{x - \tilde{x}}{\Delta t^2}
\tag{1}
\end{equation}
\]</span></p>
<p>上式的复杂程度由<span
class="math inline">\(U\)</span>的定义式决定，通常上式都是一个关于<span
class="math inline">\(x\)</span>的非线性方程。</p>
<p>典型的做法是用牛顿法进行求解。设<span
class="math inline">\(g(x)=M(x-\tilde{x})+\Delta t^2 \nabla
U\)</span>，我们就是想求它的零点，使用牛顿法进行迭代（下标<span
class="math inline">\(n\)</span>表示第<span
class="math inline">\(n\)</span>次迭代的结果）：</p>
<p><span class="math display">\[
g(x_n) + \left.\frac{∂g}{∂x}\right|_{x_n}(x_{n+1}-x_n) = 0
\]</span></p>
<p>其中<span
class="math inline">\(g(x_n)\)</span>很好求，带进去就完事了。但是<span
class="math inline">\(\left.\frac{∂g}{∂x}\right|_{x_n}\)</span>就很困难了，把它展开：</p>
<p><span class="math display">\[
\frac{∂g}{∂x} = M + Δt^2H(U)
\]</span></p>
<p>其中<span class="math inline">\(H(U)\)</span>为<span
class="math inline">\(U\)</span>关于<span
class="math inline">\(x\)</span>的黑塞矩阵，这一项通常而言都不是那么好求的。</p>
<p>当然也可以直接求<span
class="math inline">\(H(U)\)</span>，然后就继续用牛顿法进行迭代，找到1式的解，从而也就得到了隐式欧拉法的解。如果这么硬算的话，那就是对只有势能力的系统用牛顿法硬解隐式欧拉法了。</p>
<h2 id="近似求解运动方程">1. 近似求解运动方程</h2>
<p>XPBD里求解1式是用了一些技巧来近似计算的。</p>
<p>他首先假设势能可以表示为如下形式： <span class="math display">\[
U=\frac{1}{2}C^TC
\]</span></p>
<p>其中<span class="math inline">\(C=[C_0, C_1, \cdots,
C_m]^T\)</span>，<span class="math inline">\(C_i(x):R^n→R\)</span>。</p>
<p>形象一点理解这个表示的话，可以把<span
class="math inline">\(C^TC\)</span>看成是一个关于<span
class="math inline">\(C\)</span>的二次型。至于他这里的<span
class="math inline">\(\frac{1}{2}\)</span>，我个人认为是因为他的势能以<a
href="https://en.wikipedia.org/wiki/Elastic_energy">弹性势能</a>为主，就沿用过来了。</p>
<p>把这一表示代入1式，得到：</p>
<p><span class="math display">\[
\begin{equation}
M(x-\tilde{x})+ \Delta t^2∇C^TC=0
\tag{2}
\end{equation}
\]</span></p>
<p>就求解难度而言1式和2式没有区别，只是把<span
class="math inline">\(U\)</span>展开而已。注意<span
class="math inline">\(∇U=∇C^TC\)</span>。</p>
<p>为了找到能简化求解过程的方法，接下来XPBD里又引入了一个新的变量：</p>
<p><span class="math display">\[
λ = -C
\]</span></p>
<p>把它带入到2式中，将问题转换成一起求解<span class="math inline">\(λ,
x\)</span>的非线性方程组：</p>
<p><span class="math display">\[
\begin{equation}
\left\{
\begin{aligned}
    g(x, λ) &amp;= M(x-\tilde{x})-Δt^2∇C^Tλ &amp;= 0 \\
    h(x, λ) &amp;=C + λ &amp;= 0
\end{aligned}
\right.
\tag{3}
\end{equation}
\]</span></p>
<p>求解3式的难度和求解1式的难度是一样的。</p>
<p>这里我们稍作停顿，来考察一下<span
class="math inline">\(λ\)</span>是什么，引入它以后的3式与1式的区别。</p>
<p>注意到<span class="math inline">\(\frac{∂U}{∂C}=C\)</span>，所以<span
class="math inline">\(λ=-C=-\frac{∂U}{∂C}\)</span>，也就是说如果我们把<span
class="math inline">\(C\)</span>视为从<span
class="math inline">\(x\)</span>所在的<span
class="math inline">\(n\)</span>维空间到某个<span
class="math inline">\(m\)</span>维空间的<span
class="math inline">\(R^n→R^m\)</span>映射的话，那么<span
class="math inline">\(λ\)</span>就是<span
class="math inline">\(U\)</span>在这个<span
class="math inline">\(m\)</span>维空间里的负梯度，表示的是<span
class="math inline">\(U\)</span>在这个m维空间里的最速下降方向。（<span
class="math inline">\(U\)</span>在这个<span
class="math inline">\(m\)</span>维空间里就只是个二次函数而已）</p>
<p>称这一由<span class="math inline">\(C\)</span>规定的<span
class="math inline">\(m\)</span>维空间为“约束空间”，<span
class="math inline">\(h(x,λ)=0\)</span>描述的是<span
class="math inline">\(λ\)</span>与<span
class="math inline">\(U\)</span>在约束空间里的最速下降方向的接近程度。</p>
<p>因为<span
class="math inline">\(h(x,λ)=0\)</span>其实并不总是能成立，所以我们设<span
class="math inline">\(λ\)</span>所对应的势能为<span
class="math inline">\(U^*\)</span>，即<span
class="math inline">\(λ=-\frac{∂U^*}{∂C}\)</span>。</p>
<p>于是对于<span
class="math inline">\(g(x,λ)\)</span>，我们把第二项写开来就很明白了：</p>
<p><span class="math display">\[
\begin{aligned}
    ∇C^Tλ = (\frac{∂C}{∂x})^T\frac{∂U^*}{∂C} = ∇U^*
\end{aligned}
\]</span></p>
<p>[TODO：这里有个问题，<span
class="math inline">\(λ\)</span>所描述的势能也是在约束空间里的吗？还是说是另一个<span
class="math inline">\(m\)</span>维空间里？还是说其实无所谓在哪个<span
class="math inline">\(m\)</span>维空间里？]</p>
<p>于是3式可改写为：</p>
<p><span class="math display">\[
\begin{equation}
\left\{
\begin{aligned}
    g(x, U^*) &amp;= M(x-\tilde{x})-Δt^2∇U^* &amp;= 0 \\
    h(x, U^*) &amp;=C + \frac{∂U^*}{∂C} &amp;= 0
\end{aligned}
\right.
\tag{3.5}
\end{equation}
\]</span></p>
<p>如果精确求解该式的话，那么我们得到的解会和1式一样，毕竟本质只是改了个写法么。但如果我们不精确求解的话，那情况就不一样了。</p>
<p>观察3.5式，注意到<span
class="math inline">\(g(x,U^*)\)</span>描述的是解<span
class="math inline">\((x, U^*)\)</span>与精确解的接近程度，而<span
class="math inline">\(h(x,U^*)\)</span>描述的是<span
class="math inline">\(U^*\)</span>的形状与原势能场<span
class="math inline">\(U\)</span>的形状的接近程度。</p>
<p>如果<span
class="math inline">\(h(x,U^*)=0\)</span>不严格成立的话，那么我们在求解<span
class="math inline">\(g(x,U^*)=0\)</span>时相当于是换了一个势能场进行求解了。这就是XPBD最核心的部分。</p>
<p>我们先试着求解3.5式……哦，等等，<span
class="math inline">\(g\)</span>和<span
class="math inline">\(h\)</span>都是关于<span
class="math inline">\(U^*\)</span>的泛函数，解这方程组大概得用变分法了，我不会求解……</p>
<p>所以我们还是先把<span
class="math inline">\(λ\)</span>给取回来，不直接求<span
class="math inline">\(U^*\)</span>，而是求它在约束空间里的负梯度<span
class="math inline">\(λ\)</span>[TODO:
为什么这样能降低求解难度？是因为限定了<span
class="math inline">\(U^*\)</span>的形状的关系吗？]。用牛顿法求解3式，得到迭代方程组：</p>
<p>$$ <span class="math display">\[\begin{equation}
\begin{bmatrix}
M-\frac{∂(∇C^T)λ}{∂x} &amp; -∇C^T \\
∇C &amp; I
\end{bmatrix}

\begin{bmatrix}
Δx \\
Δλ
\end{bmatrix}

=
-
\begin{bmatrix}
g(x_n, λ_n) \\
h(x_n, λ_n)
\end{bmatrix}
\tag{4}
\end{equation}\]</span> $$</p>
<p>其中<span class="math inline">\(Δx=x_{n+1}-x_n,
Δλ=λ_{n+1}-λ_n\)</span>，<span
class="math inline">\(I\)</span>为单位矩阵。
最左边的系数矩阵里用的值全都是<span class="math inline">\(x_n,
λ_n\)</span>。</p>
<p>注意到<span class="math inline">\(\frac{∂(∇C^Tλ)}{∂x}=\sum_i
λ_iH(C_i)\)</span>（<span class="math inline">\(λ_i\)</span>为<span
class="math inline">\(λ\)</span>的第<span
class="math inline">\(i\)</span>个分量，注意不要跟<span
class="math inline">\(λ_n, λ_{n+1}\)</span>弄混），其中<span
class="math inline">\(H(C_i)\)</span>为<span
class="math inline">\(C_i\)</span>的Hessian矩阵。XPBD做的加速优化就集中在这里：</p>
<ol type="1">
<li>假设<span class="math inline">\(\sum_i λ_iH(C_i)=0\)</span></li>
<li>假设<span class="math inline">\(g(x_n, λ_n)=0\)</span>[TODO:
我不理解这一近似。按理来说<span class="math inline">\(g(x_n,
λ_n)\)</span>并不是多难求的东西。文中说是跟Fast
Projection算法相近的做法，尚待调研]</li>
</ol>
有了这两个近似后，4式就简化成了： $$
<span class="math display">\[\begin{bmatrix}
M &amp; -∇C^T \\
∇C &amp; I
\end{bmatrix}\]</span>
<span class="math display">\[\begin{bmatrix}
Δx \\
Δλ
\end{bmatrix}\]</span>
<h2 id="section">=</h2>
<span class="math display">\[\begin{bmatrix}
0\\
h(x_n, λ_n)
\end{bmatrix}\]</span>
<p>$$</p>
<p>这一线性方程组中<span
class="math inline">\(M\)</span>是性质很好的一项，可以用<span
class="math inline">\(M\)</span>做舒尔补求<span
class="math inline">\(Δλ\)</span>，得到计算式：</p>
<p><span class="math display">\[
\begin{equation}
\left\{
\begin{aligned}
(∇CM^{-1}∇C^T)Δλ = -C-λ \\
Δx = M^{-1}∇C^TΔλ
\end{aligned}
\right.
\tag{5}
\end{equation}
\]</span></p>
<p>显然，5式非常好求。</p>
<p>回过头去观察对4式做的近似与3.5式之间的关系。我们所做的最主要的近似是使<span
class="math inline">\(\sum_i λ_iH(C_i)=0\)</span>。
我们回忆起刚才的分析<span
class="math inline">\(λ=-\frac{∂U^*}{∂C}\)</span>，代入这一近似中即可得到<span
class="math inline">\(H(U^*)=0\)</span>。
这也就是说XPBD所做的这一近似的含义为： * 欲求的<span
class="math inline">\(U^*\)</span>这一势能场，它关于<span
class="math inline">\(x\)</span>的二阶导数为0.</p>
<p>所以我们迭代计算5式的过程其实可以视为这两步： * 先寻找关于<span
class="math inline">\(x\)</span>的二阶导为零的势能场<span
class="math inline">\(U^*\)</span>，它在约束空间(由<span
class="math inline">\(C(x)\)</span>规定的空间)里<span
class="math inline">\(x_n\)</span>点对应的点上的梯度尽量接近原势能场<span
class="math inline">\(U\)</span>的梯度。 * 随后在<span
class="math inline">\(U^*\)</span>上计算隐式欧拉法。</p>
<p>[Note Q:那为什么是要在约束空间里的梯度相近呢？在原本的<span
class="math inline">\(n\)</span>维空间里的梯度不是更好吗？A:因为那样的话<span
class="math inline">\(h(x,λ)\)</span>就变成<span
class="math inline">\(h(x,λ)=∇U+λ=0\)</span>了，在用牛顿法迭代方程组的时候不可避免地要计算<span
class="math inline">\(H(U)\)</span>。]</p>
<h1 id="五讨论">五、讨论</h1>
<p>原文里还回过头去联系了一下PBD，不过我不打算讨论那个了。阻尼也不讨论。</p>
<p>XPBD的特点我总结为三项： 1.
将运动方程分为“外力与惯性速度”和“势能力”这两部分，然后分别用不同的方法进行求解。
2.
在求解只有势能力的运动方程时使用隐式欧拉法并用牛顿法求解隐式欧拉法的非线性方程组。
3. 在牛顿法迭代时，每一步都先寻找一个关于<span
class="math inline">\(x\)</span>的二阶导为零的势能场<span
class="math inline">\(U^*\)</span>，它在由<span
class="math inline">\(C(x)\)</span>规定的<span
class="math inline">\(m\)</span>维空间里<span
class="math inline">\(x_n\)</span>所对应的点上的梯度尽量接近原势能场<span
class="math inline">\(U\)</span>的梯度（即是说，设<span
class="math inline">\(y_n=C(x_n)\)</span>，则<span
class="math inline">\(∇_CU|_{y_n} ≈ ∇_CU^{*
}|_{y_n}\)</span>），随后在求解原问题(对隐式欧拉法应用牛顿法时得到的迭代方程)时使用这一简化的势能场<span
class="math inline">\(U^*\)</span>，从而加速了求解。</p>
<p>第一点分开求解就相当于是“预测-校准”的方法。
第二步求解势能力的运动方程时就相当于是把经过第一步后偏离合法状态的系统投影回由势能函数所规定的势能最低点（n维空间中的一片区域，通常就是指<span
class="math inline">\(U=0\)</span>的流形）。
想象系统在第一步后非常幸运地一直都处在势能最低点，那么这种情况下第二步就是可有可无的。例如无空气阻力的自由下落布料就是一个典型的情况，这种情况下第一步就是对所有粒子的重力，因为粒子之间的相对位置没有发生移动，所以布料内部也就没有弹力发生，第二步也就不会做任何事情。</p>
<p>第二点没什么好说的，就只是选用了隐式欧拉法和牛顿法而已。</p>
<p>第三点是他最主要的提速方法，每一步都寻找一个二阶导为零的势能场来近似原势能场。</p>
<p>这里我的一个思考是<span
class="math inline">\(C\)</span>所规定的约束空间到底是什么？<span
class="math inline">\(U^*\)</span>和<span
class="math inline">\(U\)</span>在<span
class="math inline">\(C\)</span>上的梯度相近的物理含义又是什么？尚待进一步思考。</p>
<p>除了这三点以外，原文中还作为一个突出亮点的是在构造势能时引入的compliance
matrix: <span
class="math inline">\(U=\frac{1}{2}C^Tα^{-1}C\)</span>。</p>
<p>这个量的本质是在调控势能力的大小：显然势能的数值范围越大（乘上的系数越大，数值范围也就越大），其梯度也就越大，也就是势能力越大。
落实到<span class="math inline">\(α\)</span>的话，就是<span
class="math inline">\(α\)</span>越小，势能力越大。当<span
class="math inline">\(α=0\)</span>时，势能力就达到无穷大。
这一项，咋说呢，我觉得其实不是那么重要，只是用来方便手动调参的而已，如果精巧设计势能函数的话其实也能达到一样的效果。</p>
<p>[TODO 寻找近似势能场这一做法似乎其实和ADMM很类似？还有Projective
Dynamics是不是也可以这么解释？]</p>
<h1 id="追记拉格朗日乘数法视点">2022/5/21追记：拉格朗日乘数法视点</h1>
<p>在Projective
Dynamics的论文里注意到这一解释PBD的视点，觉得也挺有意思，就记录一下。</p>
<p>回顾式1： <span class="math display">\[
\begin{equation}
-∇U(x) = M\frac{x - \tilde{x}}{\Delta t^2}
\tag{1}
\end{equation}
\]</span></p>
<p>重新排下顺序： <span class="math display">\[
M(x - \tilde{x}) + Δt^2∇U(x) = 0
\]</span></p>
<p>对它左边关于<span
class="math inline">\(x\)</span>求个不定积分，得到函数<span
class="math inline">\(Φ\)</span>： <span class="math display">\[
Φ(x) = \frac{1}{2}(x-\tilde{x})^TM(x-\tilde{x})+Δt^2U(x)
\]</span></p>
<p>有<span class="math inline">\(∇Φ=M(x - \tilde{x}) +
Δt^2∇U(x)\)</span>。</p>
<p>那么在1式的解<span class="math inline">\(x^*\)</span>附近对<span
class="math inline">\(Φ\)</span>求极值点等价于直接求解1式。（因为极值点处<span
class="math inline">\(Φ\)</span>的梯度为0）（注意现在局部性还不能舍弃，因为<span
class="math inline">\(U\)</span>是个未知形状的函数）</p>
<p>这就是最近挺流行的最优化视点，在这一视点下看XPBD的话，当然也可以按照本文的看法去处理，不过也可以从拉格朗日乘数法的视点去处理。</p>
<p>我们先把<span class="math inline">\(U\)</span>给扔掉，只看约束<span
class="math inline">\(C(x)=0\)</span>，那么此时要求函数<span
class="math inline">\(Φ\)</span>的极值点，就是要求解以下条件极值问题：</p>
<p><span class="math display">\[
\begin{aligned}
    \min_x\ &amp;Φ(x)=\frac{1}{2}(x-\tilde{x})^TM(x-\tilde{x}) \\
    s.t.\ &amp;C(x)=0
\end{aligned}
\]</span></p>
<p>这应该是很显然的，意思就是在<span
class="math inline">\(C(x)=0\)</span>的前提下找到<span
class="math inline">\(Φ(x)\)</span>的最小值。</p>
<p>使用拉格朗日乘数法的方法将该问题转换为无条件极值问题，引入<span
class="math inline">\(m\)</span>维列向量<span
class="math inline">\(λ\)</span>：</p>
<p><span class="math display">\[
\min_x\ \frac{1}{2}(x-\tilde{x})^TM(x-\tilde{x})+λ^TC(x)
\]</span></p>
<p>此处做一个近似，在<span
class="math inline">\(\tilde{x}\)</span>处线性化<span
class="math inline">\(C(x)\)</span>：<span
class="math inline">\(C(x)≈C(\tilde{x})+∇C(\tilde{x})(x-\tilde{x})\)</span>，代入得到：</p>
<p><span class="math display">\[
\min_x\
\frac{1}{2}(x-\tilde{x})^TM(x-\tilde{x})+λ^T[C(\tilde{x})+∇C(\tilde{x})(x-\tilde{x})]
\]</span></p>
<p>求解该无条件极值问题，就是对它分别求关于<span
class="math inline">\(x\)</span>和<span
class="math inline">\(λ\)</span>的导数，并使导数为0，也就是要求解以下方程组：</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
    MΔx+∇C(\tilde{x})^Tλ=0 \\
    C(\tilde{x})+∇C(\tilde{x})(x-\tilde{x}) = 0
\end{aligned}
\right.
\]</span></p>
</body>
</html>
