<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>测试用博客</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="https://gist.githubusercontent.com/supplient/1726b3acbfed278f54b66cf11129a43b/raw/62b874d98f72005d18b9b2a05d3be6815959b51b/gh-pandoc.css" />
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">测试用博客</h1>
</header>
<p>#! https://zhuanlan.zhihu.com/p/518244355 #
论文阅读：XPBD（最优化视点）</p>
<p>本文为对<a
href="https://matthias-research.github.io/pages/publications/XPBD.pdf">XPBD:
Position-Based Simulation of Compliant Constrained
Dynamics</a>的阅读笔记。</p>
<p>本文站的视点和原文已经截然不同了，完全可以把本文当作独立的文章进行阅读。</p>
<p>本文里所介绍的方法是我按个人理解提炼出来的，和原文也稍许有一些些出入（例如我没有近似<span
class="math inline">\(g(x,λ)=0\)</span>），但内核应该是一样的。</p>
<p>本文跟我的<a
href="https://zhuanlan.zhihu.com/p/510654097">另一篇对XPBD的阅读笔记</a>站的视点稍有不同，所以另外写了这一篇。
我个人是觉得这篇里的内容更加易于理解，但也和原文出入更大。</p>
<p>一些记号约定： * 位移为<span
class="math inline">\(x\)</span>，速度为<span
class="math inline">\(v\)</span>，加速度为<span
class="math inline">\(a\)</span>，时间为<span
class="math inline">\(t\)</span>。 * 共<span
class="math inline">\(n\)</span>个质点。 *
所有向量均为列向量。标量对<span
class="math inline">\(n\)</span>维向量求导，结果为<span
class="math inline">\(n\)</span>维向量；<span
class="math inline">\(m\)</span>维向量对<span
class="math inline">\(n\)</span>维向量求导，结果为<span
class="math inline">\(m\)</span>行<span
class="math inline">\(n\)</span>列矩阵。 * 上标表示时刻，例如<span
class="math inline">\(x^n\)</span>表示第<span
class="math inline">\(n\)</span>个时刻的位移。 *
下标表示某个质点的值，例如<span
class="math inline">\(x_i\)</span>表示第<span
class="math inline">\(i\)</span>个质点的位移。 * 已知<span
class="math inline">\(n\)</span>时刻的所有状态信息，包括但不限于<span
class="math inline">\(x, v,
a\)</span>。（注意这里为了和其他地方的标记统一，所以<span
class="math inline">\(n\)</span>同时具有<span
class="math inline">\(n\)</span>维和第<span
class="math inline">\(n\)</span>个时刻的含义，有点混用了） *
质量矩阵为对角矩阵<span class="math inline">\(M=diag\{m_1, m_2, \cdots,
m_n\}\)</span>，其中<span class="math inline">\(m_i\)</span>为第<span
class="math inline">\(i\)</span>个质点的质量。设质量与时间无关，始终不变。
* <span class="math inline">\(\Delta
t\)</span>为时步长度，即每帧之间的时间长度<span
class="math inline">\(Δt=t^{n+1}-t^n\)</span>。</p>
<h1 id="方法">1. 方法</h1>
<p>我们的目标是要求出当前位移<span
class="math inline">\(x\)</span>，根据速度定义，其满足：</p>
<p><span class="math display">\[
\tag{1.1}
x^{n+1} = x^n + \int_{t^n}^{t^{n+1}}vdt
\]</span></p>
<p>速度又根据加速度定义，满足：</p>
<p><span class="math display">\[
\tag{1.2}
v = v^n + \int_{t^n}^{t}adt
\]</span></p>
<p>根据牛顿第二定律，可知：</p>
<p><span class="math display">\[
\tag{1.3}
a=M^{-1}F
\]</span></p>
<p>把式1.3代入到式1.2里，就能求出<span
class="math inline">\(v\)</span>关于<span
class="math inline">\(t\)</span>的函数，然后再代进式1.1里就能求出<span
class="math inline">\(x^{n+1}\)</span>关于<span
class="math inline">\(t^{n+1}\)</span>的函数。 不过因为<span
class="math inline">\(F\)</span>通常都很复杂，所以直接求积分不太现实，使用数值积分的方法近似求解比较现实。</p>
<p>对式1.1, 1.2<strong>应用隐式欧拉法（第一个处理）</strong>：</p>
<p><span class="math display">\[
\left\{
\begin{aligned}
    x^{n+1} = x^n + Δtv^{n+1} \\
    v^{n+1} = v^n + Δta^{n+1} \\
\end{aligned}
\right.
\]</span></p>
<p>这一近似就让<span
class="math inline">\(x^{n+1}\)</span>变得更容易求解了。为了让解更加明显，我们对它稍作变形，把下式的<span
class="math inline">\(v^{n+1}\)</span>代进上式，从而消掉并不是目标项的<span
class="math inline">\(v^{n+1}\)</span>，得到：</p>
<p><span class="math display">\[
x^{n+1}=x^n+Δtv^n+Δt^2a^{n+1}
\]</span></p>
<p>求解这一关于<span class="math inline">\(x^{n+1}\)</span>的方程即可。
不过<span class="math inline">\(a^{n+1}\)</span>还没有展开。
如果展开的话，因为<span
class="math inline">\(a^{n+1}=M^{-1}F^{n+1}\)</span>， 而<span
class="math inline">\(F^{n+1}\)</span>通常都是关于<span
class="math inline">\(x^{n+1}\)</span>或<span
class="math inline">\(v^{n+1}\)</span>的非线性函数，
这就导致上式变成了一个关于<span
class="math inline">\(x^{n+1}\)</span>的非线性方程。
我们希望能求解得更容易点。</p>
<p>我们先把这个非线性方程给写出来，为了方便，记<span
class="math inline">\(Δx=x^{n+1}-x^n-Δtv^n\)</span>。则有方程：</p>
<p><span class="math display">\[
\tag{1.4}
MΔx-Δt^2F(Δx)=0
\]</span></p>
<p>我们的目标是求解式1.4，这在解附近等价于求解以下最优化问题：</p>
<p><span class="math display">\[
\min_{Δx}\ G(Δx)=\frac{1}{2}Δx^TMΔx-Δt^2∫F(Δx)d(Δx)
\]</span></p>
<p>这是因为在没有约束条件的情况下，<span
class="math inline">\(G(Δx)\)</span>的极值点必定满足<span
class="math inline">\(\frac{∂G}{∂Δx}=MΔx-Δt^2F(Δx)=0\)</span>，也就是1.4式成立。</p>
<p>为了能方便地处理<span
class="math inline">\(F\)</span>，此处再引入一个假设：<strong><span
class="math inline">\(F\)</span>为保守力（第二个处理）</strong>，即有势能场<span
class="math inline">\(U\)</span>满足：</p>
<p><span class="math display">\[
∇U=-F
\]</span></p>
<p>则最优化问题可记为：</p>
<p><span class="math display">\[
\tag{1.5}
\min_{Δx}\ G(Δx)=\frac{1}{2}Δx^TMΔx-Δt^2U(Δx)
\]</span></p>
<p><span class="math inline">\(G\)</span>的前半项<span
class="math inline">\(\frac{1}{2}Δx^TMΔx\)</span>是个关于<span
class="math inline">\(Δx\)</span>的二次项，求它的极值点很容易。
所以<span class="math inline">\(G\)</span>的复杂度由其后半项<span
class="math inline">\(U\)</span>来决定。 通常而言，<span
class="math inline">\(U\)</span>都挺复杂的，不是一个简单的二次函数。</p>
<p>所以我们这里再引入一个假设：<strong>U为关于某个变量的二次函数（第三个处理）</strong>，即：</p>
<p><span class="math display">\[
U=\frac{1}{2}C^Tα^{-1}C
\]</span></p>
<p>其中<span class="math inline">\(C:R^n→R^m\)</span>，<span
class="math inline">\(α\)</span>为一个<span
class="math inline">\(m\)</span>维的对角矩阵。（注意这一处理没有近似，也并没有显著降低求解难度，但它会对<span
class="math inline">\(U\)</span>的结构做出一定的限制，以便后续处理。）</p>
<p>在这一假设下求解式1.5的话，如果<span
class="math inline">\(C\)</span>复杂的话，那依然要求解一个关于<span
class="math inline">\(Δx\)</span>的非线性方程。写出来的话就是：</p>
<p><span class="math display">\[
\frac{∂G}{∂Δx}=MΔx-Δt^2∇C^Tα^{-1}C=0
\]</span></p>
<p>只要<span class="math inline">\(∇Cα^{-1}C\)</span>不是关于<span
class="math inline">\(Δx\)</span>的线性函数，那这就依然是个关于<span
class="math inline">\(Δx\)</span>的非线性方程。</p>
<p>此处我们<strong>引入一个新变量<span
class="math inline">\(λ\)</span>，并重新构造势能场（第四个处理）</strong>：</p>
<p><span class="math display">\[
U^*=-λ^TC-\frac{1}{2}λ^Tαλ
\]</span></p>
<p><span class="math inline">\(U^*\)</span>的特点是当<span
class="math inline">\(\frac{∂U^*}{∂λ}=0\)</span>时，<span
class="math inline">\(U^*=U\)</span>（这是因为<span
class="math inline">\(\frac{∂U^*}{∂λ}=0 ⇒ λ=-α^{-1}C ⇒
U^*=C^Tα^{-1}C-\frac{1}{2}C^Tα^{-1}C=\frac{1}{2}C^Tα^{-1}C=U\)</span>）。
这一特点意味着<span
class="math inline">\(U^*\)</span>在其极值点上总是与<span
class="math inline">\(U\)</span>等价。</p>
<p>此时我们就得到了一个和式1.5同解的二元函数求极值的问题：</p>
<p><span class="math display">\[
\tag{1.6}
\min_{Δx,λ}\ G(Δx, λ)=\frac{1}{2}Δx^TMΔx-Δt^2U^*(Δx, λ)
\]</span></p>
<p>（注意这一处理依然没有降低求解难度，但是它扩大了最优化问题的搜索空间，在优化<span
class="math inline">\(U(C,λ)\)</span>时，搜索空间从<span
class="math inline">\(λ=-α^{-1}C\)</span>的直线上扩展到了整个<span
class="math inline">\(λ-C\)</span>平面，后文详述）</p>
<p>求解该问题依然复杂，这里我们就引入了惯用的近似假设：<strong>设<span
class="math inline">\(U^*\)</span>关于<span
class="math inline">\(Δx\)</span>的二阶导数<span
class="math inline">\(H(U^*)\)</span>为0（第五个处理）</strong>。也即是说<span
class="math inline">\(U^*\)</span>是个关于<span
class="math inline">\(Δx\)</span>的线性函数。</p>
<p>于是式1.6里的<span class="math inline">\(G(Δx,
λ)\)</span>就是个关于<span
class="math inline">\(Δx\)</span>的二次函数，也是个关于<span
class="math inline">\(λ\)</span>的二次函数。求它的极值点非常容易，我们分别对<span
class="math inline">\(Δx\)</span>和<span
class="math inline">\(λ\)</span>求导，得到方程组：</p>
<p><span class="math display">\[
\tag{1.7}
\left\{
\begin{aligned}
    \frac{∂G}{∂Δx}&amp;=MΔx-Δt^2∇C^Tλ&amp;=0 \\
    \frac{∂G}{∂λ} &amp;=C+αλ         &amp;=0 \\
\end{aligned}
\right.
\]</span></p>
<p>因为假设了<span class="math inline">\(H(U^*)=0\)</span>，所以<span
class="math inline">\(∇C^Tλ\)</span>是个常数项，于是上式就是个关于<span
class="math inline">\(Δx,
λ\)</span>的线性方程组。至此，我们就得到了一套求解式1.1的方法。</p>
<p>实际求的时候可以对<span
class="math inline">\(U^*(x^{n+1})\)</span>在<span
class="math inline">\(\tilde{x}=x^n+Δtv^n\)</span>做泰勒展开：</p>
<p><span class="math display">\[
U^*(x^{n+1})=U^*(\tilde{x})+∇U^*(\tilde{x})Δx+O(Δx^2)
\]</span></p>
<p>然后略去二次项的话，那就达成了假设<span
class="math inline">\(H(U^*)=0\)</span>的目的。</p>
<h1 id="讨论">2. 讨论</h1>
<p>我们为了求解式1.1里的<span
class="math inline">\(x^{n+1}\)</span>，一共做了五个处理： 1.
应用隐式欧拉法计算数值积分 2.
假设作用力均为保守力，从而可以将原问题转换为最优化问题 3. 规定<span
class="math inline">\(U=\frac{1}{2}C^Tα^{-1}C\)</span>，限制了<span
class="math inline">\(U\)</span>的结构。 4.
引入新变量，并构造一个新的势能场<span
class="math inline">\(U^*=-λ^TC-\frac{1}{2}λ^Tαλ\)</span> 5. 假设<span
class="math inline">\(H(U^*)=0\)</span>，将目标函数变为一个二次函数。</p>
<p>第一、五个处理是降低求解难度的核心步骤： *
第一个处理用近似方法计算数值积分。 *
第五个处理相当于是应用了一次泰勒展开，将一个复杂函数线性化了。</p>
<p>第二、三个处理限定了力的性质，为第四个处理铺路： *
第二个处理限定作用力必须为保守力，也就必须有一个势能场对应它。 *
第三个处理限定了这一势能场的形状，规定它必须是关于某个变量的二次函数。</p>
<p>第四个处理扩大了搜索空间，修正了解空间，从而提高了近似解的准确度。
这一点需要稍微深入讨论一下。</p>
<p>假设我们不引入<span
class="math inline">\(λ\)</span>，而是直接假设<span
class="math inline">\(H(U)=0\)</span>，那么依然是可以将式1.5的目标函数<span
class="math inline">\(G\)</span>转变成一个二次函数进行快速求解的。
但是注意到求解式1.5时，我们仅在<span
class="math inline">\(x\)</span>轴上进行搜索，而因为我们引入了近似<span
class="math inline">\(H(U)=0\)</span>，所以此时<span
class="math inline">\(x\)</span>轴上的最小值可能已经离精确解很远了。</p>
<p>为了形象直观地理解这一问题， 我们考虑一个函数<span
class="math inline">\(z=x^2\)</span>， 显然它的极小值点是在<span
class="math inline">\(x=0\)</span>的位置上。
如果我们对这一函数做稍许的扰动， 得到一个新函数<span
class="math inline">\(z&#39;=(x-5)^2\)</span>，
那么此时极小值点就是在<span class="math inline">\(x=5\)</span>上了，
跟原来的<span class="math inline">\(x=0\)</span>相距甚远。</p>
<p>为此我们需要扩大搜索空间，并修正解空间，以更加接近精确解。
引入辅助变量<span class="math inline">\(y\)</span>， 并设新函数<span
class="math inline">\(ϕ=(x-5)^2+xy\)</span>，
简单求导后可以得到新函数的极值点为<span class="math inline">\(x=0,
y=10\)</span>， 发现它回到了原来的极值点<span
class="math inline">\(x=0\)</span>上。</p>
<p>我们近似<span
class="math inline">\(H(U)=0\)</span>的结果和上面的“稍许的扰动”是类似的，
所以我们在这一新函数上的搜索结果和原函数的极值点可能相距甚远。
为此我们引入了辅助变量<span
class="math inline">\(λ\)</span>，并设新的势能函数<span
class="math inline">\(U^*=-λ^TC-\frac{1}{2}λ^Tαλ\)</span>，
这跟上面引入<span class="math inline">\(y\)</span>和<span
class="math inline">\(ϕ\)</span>是类似的， 目的当然也是雷同的：
我们想尽量抵消掉一些近似<span
class="math inline">\(H(U)=0\)</span>带来的扰动，以得到更精确的解。</p>
</body>
</html>
