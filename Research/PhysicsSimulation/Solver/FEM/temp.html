<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>测试用博客</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="https://gist.githubusercontent.com/supplient/1726b3acbfed278f54b66cf11129a43b/raw/62b874d98f72005d18b9b2a05d3be6815959b51b/gh-pandoc.css" />
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">测试用博客</h1>
</header>
<p>我们希望trial space <span class="math inline">\(V\)</span> 能让弱形式
<span class="math inline">\(a(u,v) = L(v) \quad \forall v \in V\)</span>
的计算方便又轻松。 其中一个选项就是将分段多项式函数作为trial function
<span class="math inline">\(u\)</span> 。</p>
<p>将定义域<span
class="math inline">\(\Omega\)</span>剖分，得到剖分<span
class="math inline">\(\mathcal{T}\)</span>。
设剖分中每个单元(element)<span
class="math inline">\(K_i\)</span>内的插值函数为<span
class="math inline">\(\mathcal{I}_{K_i}f\)</span>， 则trial
function为全局的插值函数<span class="math inline">\(\mathcal{I}f|_{K_i}
= \mathcal{I}_{K_i}f\)</span>， trial space <span
class="math inline">\(V = \{\mathcal{I}f: f \in
\mathcal{F}\}\)</span>。</p>
<p>为单元<span class="math inline">\(K\)</span>内的局部插值函数<span
class="math inline">\(\mathcal{I}_{K}f\)</span>做定义。
设每个单元中都有三元组<span class="math inline">\((K, \mathcal{P},
\mathcal{N})\)</span>：</p>
<ul>
<li><span
class="math inline">\(K\)</span>为该单元的定义域，称为单元域element
domain。</li>
<li><span class="math inline">\(\mathcal{P}\)</span>为<span
class="math inline">\(K\)</span>上的一个有限维函数空间，称为shape
function的所在空间。</li>
<li><span class="math inline">\(\mathcal{N}=\{N_1, N_2, \dots,
N_k\}\)</span>为<span class="math inline">\(P\)</span>的对偶空间<span
class="math inline">\(P&#39;\)</span>中的一组基，称为nodal variables。
<ul>
<li><span class="math inline">\(\mathcal{N}\)</span>的一个例子是<span
class="math inline">\(N_i(v)=v(x_i)\)</span>，也就是说<span
class="math inline">\(N_i\)</span>接收<span
class="math inline">\(\mathcal{P}\)</span>中的一个函数，然后返回该函数在<span
class="math inline">\(x_i\)</span>上的取值。</li>
<li>另一个例子是<span
class="math inline">\(N_i(v)=v&#39;(x_i)\)</span>，此时<span
class="math inline">\(N_i\)</span>接收<span
class="math inline">\(\mathcal{P}\)</span>中的一个函数，然后返回该函数在<span
class="math inline">\(x_i\)</span>上的一阶导数。</li>
</ul></li>
</ul>
<p>若<span class="math inline">\(\mathcal{P}\)</span>中的一组基<span
class="math inline">\(\{\phi_1, \phi_2, \dots,
\phi_k\}\)</span>满足<span
class="math inline">\(N_i(\phi_j)=\delta_{ij}\)</span>（<span
class="math inline">\(i=j \Rightarrow \delta_{ij}=1 ; i\neq j
\Rightarrow \delta_{ij}=0\)</span>），则称这组基<span
class="math inline">\(\{\phi_i\}\)</span>为nodal basis。</p>
<ul>
<li>例如当<span class="math inline">\(N_i(v)=v(x_i)\)</span>时，<span
class="math inline">\(N_i(\phi_j)=\phi_j(x_i)\)</span>，若<span
class="math inline">\(\{\phi_j\}\)</span>为nodal basis的话，则<span
class="math inline">\(\phi_j(x_i)=\delta_{ij}\)</span>意味着<span
class="math inline">\(\phi_j\)</span>是一个仅在<span
class="math inline">\(x_j\)</span>处取值为1而在其他所有<span
class="math inline">\(x_i\)</span>处都取值为0的函数（例子就是克罗内克函数<span
class="math inline">\(\delta_{ij}\)</span>）。</li>
</ul>
<p>则局部插值函数<span
class="math inline">\(\mathcal{I}_{K}f\)</span>定义为：</p>
<p><span class="math display">\[
\mathcal{I}_{K}f = \sum_{i=1}^k N_i(f)\phi_i
\]</span></p>
<p>不同的<span class="math inline">\((K, \mathcal{P},
\mathcal{N})\)</span>就构成了不同类型的有限元:</p>
<ul>
<li><span class="math inline">\(K\)</span>为三角形时为Triangular Element
<ul>
<li><span
class="math inline">\(N_i(v)=v(z_i)\)</span>时，该有限元为Lagrange
Element
<ul>
<li>可以选取不同的<span
class="math inline">\(\mathcal{P}\)</span>和<span
class="math inline">\(\mathcal{N}\)</span>，只要满足<span
class="math inline">\(\mathcal{N}\)</span>为<span
class="math inline">\(\mathcal{P}\)</span>的一组基即可。</li>
<li>例如<span
class="math inline">\(\mathcal{P}=\mathcal{P}_1\)</span>，<span
class="math inline">\(\mathcal{N}=\{N_1, N_2, N_3\}\)</span>，<span
class="math inline">\(z_i\)</span>为<span
class="math inline">\(K\)</span>的三个顶点。</li>
</ul></li>
<li>Hermite Element会要求有<span
class="math inline">\(N_i(v)=v&#39;(z_i)\)</span>，Argyris
Element会要求有<span
class="math inline">\(N_i(v)=v&#39;&#39;(z_i)\)</span>，这两类在此略过。</li>
</ul></li>
<li><span class="math inline">\(K\)</span>为四边形时为Rectangular
Element，其他形状时也都类似，例如Tetrahedron Element，Cuboid
Element。</li>
</ul>
<p>而不同类型的有限元就定义了不同的局部插值函数<span
class="math inline">\(\mathcal{I}_Kf\)</span>，从而也就定义了不同的全局插值函数<span
class="math inline">\(\mathcal{I}f\)</span>，产生了不同的trial space
<span class="math inline">\(V=\{\mathcal{I}f: f\in
\mathcal{F}\}\)</span>。</p>
<p>用有限元定义的全局插值函数具有下面两个在Garlekin
Method里特别实用的性质：</p>
<ul>
<li>3.3.17连续性：Lagrange Element和Hermite Element定义的<span
class="math inline">\(\mathcal{I}f \in C^0\)</span>，Angyris
Element定义的<span class="math inline">\(\mathcal{I}f \in C^1\)</span>。
<ul>
<li>这确保了一阶导数的存在。</li>
</ul></li>
<li>误差估计
<ul>
<li>4.4.28导数误差估计：用Lagrange, Hermite, Angyris Element定义的<span
class="math inline">\(\mathcal{I}f\)</span>在使用Garlekin
Method求解<span class="math inline">\(u\)</span>时都满足误差估计<span
class="math inline">\(||u-\mathcal{I}u||_{H^1(\Omega)} \leq C
h^m||u||_{H^{m+1}(\Omega)}\)</span>
<ul>
<li>其中<span
class="math inline">\(C\)</span>为一个与有限元单元形状有关的常数，<span
class="math inline">\(h\in
(0,1]\)</span>为有限元单元相对于定义域全局的大小比例（也就是<span
class="math inline">\(h\)</span>越小，剖分得就越细、单元就越小），<span
class="math inline">\(m\)</span>为有限元定义中的<span
class="math inline">\(\mathcal{P}\)</span>对应的阶次（即<span
class="math inline">\(P=P^m\)</span>），<span
class="math inline">\(H^m=W^m_2\)</span>为索博列夫空间</li>
<li>可以大致理解为：导数误差<span
class="math inline">\(||u&#39;-\mathcal{I}u&#39;||\)</span>总是关于<span
class="math inline">\(h^m\)</span>成线性关系</li>
</ul></li>
<li>5.4.8解误差估计：<span
class="math inline">\(||u-\mathcal{I}u||_{L^2(\Omega)} \leq C h^{m+1}
||u||_{H^{m+1}(\Omega)}\)</span>
<ul>
<li>可以大致理解为：误差<span
class="math inline">\(||u-\mathcal{I}u||\)</span>总是关于<span
class="math inline">\(h^{m+1}\)</span>成线性关系</li>
</ul></li>
<li>总的来说就是当有限元定义中使用<span
class="math inline">\(m\)</span>阶多项式时，误差<span
class="math inline">\(||u-\mathcal{I}u||=O(h^{m+1})\)</span>，<span
class="math inline">\(O(\cdot)\)</span>为渐进大<span
class="math inline">\(O\)</span>记号。</li>
</ul></li>
</ul>
<h1 id="参考文献">参考文献</h1>
<p>【TODO】</p>
</body>
</html>
